package org.eclipse.viatra.dslreasoner.patternmutator

import epackage "FAM";
pattern modelV0(This: FunctionalElement, Target: FunctionalArchitectureModel) {				
	FunctionalElement(This);
	FunctionalArchitectureModel(Target);
}


pattern typeV0(This: Function, Target: FunctionType) {				
	Function(This);
	neg find parentV0(_Child, This);	
	neg find rootElementsV0(_Model, This);	
	Target == FunctionType::Leaf;
} or {
	find parentV0(This, _Par);	
	find parentV0(_Child, This);	
	Target == FunctionType::Intermediate;
} or {
	find rootElementsV0(_Model, This);	
	Target == FunctionType::Root;
}


pattern parentV0(Func: Function, Par: Function) {				
	Function(Func);
	FunctionalElement.parent(Func, Par);		
}


pattern hasIntV0(F: Function) {				
	Function(F);
	neg find parentV0(_Child, F);	
	neg find rootElementsV0(_Model, F);	
}


pattern noIntV0(fam: FunctionalArchitectureModel) {				
	FunctionalArchitectureModel(fam);
	neg find hasIntV0(_);	
}


pattern hasRootV0(F: Function) {				
	find rootElementsV0(_Model, F);	
}


pattern noLeafV0(fam: FunctionalArchitectureModel) {				
	FunctionalArchitectureModel(fam);
	neg find hasLeafV0(_);	
}


pattern hasLeafV0(F: Function) {				
	find parentV0(F, _Par);	
	find parentV0(_Child, F);	
}


pattern rootElementsV0(Model: FunctionalArchitectureModel, Root: Function) {				
	Function(Root);
	FunctionalArchitectureModel.rootElements(Model, Root);		
}


pattern terminatorAndInformationV0(T: FAMTerminator, I: InformationLink) {				
	InformationLink.to(I, In);		
	FunctionalData.terminator(In, T);		
} or {
	FunctionalOutput.outgoingLinks(Out, I);		
	FunctionalData.terminator(Out, T);		
}


pattern noRootV0(fam: FunctionalArchitectureModel) {				
	FunctionalArchitectureModel(fam);
	neg find hasRootV0(_);	
}


