package org.eclipse.viatra.dslreasoner.patternmutator

import epackage "FAM";
@Constraint
pattern terminatorAndInformationV0(T: FAMTerminator, I: InformationLink) {				
	FunctionalOutput.outgoingLinks(I, Out);		
	FunctionalData.terminator(Out, T);		
} or {
	InformationLink.to(I, In);		
	FunctionalData.terminator(T, In);		
}


@Constraint
pattern noIntV0(fam: FunctionalArchitectureModel) {				
	FunctionalArchitectureModel(fam);
	neg find hasIntV0(_<0>);	
}


pattern parentV0(Func: Function, Par: Function) {				
	Function(Func);
	FunctionalElement.parent(Func, Par);		
}


@Constraint
pattern noRootV0(fam: FunctionalArchitectureModel) {				
	FunctionalArchitectureModel(fam);
	neg find hasRootV0(_<0>);	
}


pattern rootElementsV0(Model: FunctionalArchitectureModel, Root: Function) {				
	Function(Root);
	FunctionalArchitectureModel.rootElements(Root, Model);		
}


@QueryBasedFeature
pattern modelV0(This: FunctionalElement, Target: FunctionalArchitectureModel) {				
	FunctionalElement(This);
	FunctionalArchitectureModel(Target);
}


pattern hasLeafV0(F: Function) {				
	find parentV0(_Par, F);	
	find parentV0(_Child, F);	
}


pattern hasIntV0(F: Function) {				
	Function(F);
	neg find parentV0(F, _Child);	
	neg find rootElementsV0(F, _Model);	
}


@QueryBasedFeature
pattern typeV0(This: Function, Target: FunctionType) {				
	find parentV0(This, _Par);	
	find parentV0(This, _Child);	
} or {
	Function(This);
	neg find parentV0(This, _Child);	
	neg find rootElementsV0(This, _Model);	
} or {
	find rootElementsV0(_Model, This);	
}


@Constraint
pattern noLeafV0(fam: FunctionalArchitectureModel) {				
	FunctionalArchitectureModel(fam);
	neg find hasLeafV0(_<0>);	
}


pattern hasRootV0(F: Function) {				
	find rootElementsV0(F, _Model);	
}
