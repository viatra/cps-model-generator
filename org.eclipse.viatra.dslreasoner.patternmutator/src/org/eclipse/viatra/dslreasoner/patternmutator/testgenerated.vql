package org.eclipse.viatra.dslreasoner.patternmutator

import epackage "FAM";
/*
 * @Constraint
pattern noRootV0(fam: FunctionalArchitectureModel) {				
	FunctionalArchitectureModel(fam);
	neg find hasRoot(_<0>);	
}


@QueryBasedFeature
pattern typeV0(This: Function, Target: FunctionType) {				
	find parent(This, _Par);	
	find parent(This, _Child);	
} or {
	find rootElements(This, _Model);	
} or {
	Function(This);
	Function(Target);
	neg find parent(_Child, This);	
	neg find rootElements(_Model, This);	
}


@Constraint
pattern terminatorAndInformationV0(T: FAMTerminator, I: InformationLink) {				
	FunctionalOutput.outgoingLinks(T, I);		
	FunctionalData.terminator(T, I);		
} or {
	InformationLink.to(T, I);		
	FunctionalData.terminator(T, I);		
}


pattern hasRootV0(F: Function) {				
	find rootElements(F, _Model);	
}


pattern hasIntV0(F: Function) {				
	Function(F);
	neg find parent(_Child, F);	
	neg find rootElements(_Model, F);	
}


@Constraint
pattern noLeafV0(fam: FunctionalArchitectureModel) {				
	FunctionalArchitectureModel(fam);
	neg find hasLeaf(_<0>);	
}


pattern rootElementsV0(Model: FunctionalArchitectureModel, Root: Function) {				
	Function(Model);
	Function(Root);
	FunctionalArchitectureModel.rootElements(Model, Root);		
}


@QueryBasedFeature
pattern modelV0(This: FunctionalElement, Target: FunctionalArchitectureModel) {				
	find rootElements(This, Target);	
} or {
	find rootElements(Target, Parent);	
}


pattern interfaceDataV0(FI: FunctionalInterface, FD: FunctionalData) {				
	FunctionalInterface.data(FI, FD);		
}


pattern parentV0(Func: Function, Par: Function) {				
	Function(Func);
	Function(Par);
	FunctionalElement.parent(Func, Par);		
}


pattern hasLeafV0(F: Function) {				
	find parent(_Par, F);	
	find parent(F, _Child);	
}


@Constraint
pattern noIntV0(fam: FunctionalArchitectureModel) {				
	FunctionalArchitectureModel(fam);
	neg find hasInt(_<0>);	
}*/